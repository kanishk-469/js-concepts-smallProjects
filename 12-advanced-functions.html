<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Function</title>
</head>
<body>
  <button onclick="" class="js-click-btn">Click</button>


  <script>
/* 
  .addEventListner(event,function); method or web API - Let us run some code when we interact with the Element,
  alternative of (attribute)onclick='';
  1) 1ST parameter event -- WHAT TYPE OF INTERACTION WE LISTEN TO. 
  2) 2nd parameter function -- Any function we can run. 
  Advantage of .addEventListener over onclick attribute
  1) Multiple Event Listeners we can add for one event
  2) We can remove an event Listener by using .removeEventListener(); 
*/

  const buttonElement = window.document.querySelector('.js-click-btn');
  const eventListHandler =  () => {
    console.log('click');
  };

  buttonElement.addEventListener('click',eventListHandler);

  buttonElement.removeEventListener('click',eventListHandler)

  buttonElement.addEventListener('click', () => {
    console.log('click2');
  });
/* End of Conclusion of onclick and addEventListener */


//     // greeting();
//     // function greeting(){
//     //   console.log('I am a function with a name greeting!!');
//     // }
//     // greeting();

//     // const greet = function(){
//     //   console.log('I am a Anonymous function !!');

//     // }
//     // greet();

//     // const arrowFn = ()=> {
//     //   console.log('I am a Arrow function..!!');
//     // }
//     // arrowFn();

//     // console.log(typeof arrowFn);
//     // console.log(typeof greet);
//     // console.log(typeof greeting);

//     // const num = 2;
//     // const objectWithMethd = {
//     //   numbr : num,
//     //   fun : function(){
//     //     console.log('I am a method inside Object');
//     //   }
//     // };
//     // objectWithMethd.fun();

//     // function display(param){
//     //   console.log('I am having parameter '+ param);
//     // }
//     // display(2);


//     // function run(param){
//     //   param('from 1st function');
      
//     // }

//     // run(function (str){
//     //   console.log('I am a function passing as an argument to another function: '+str);
//     // });

//     // /*setTimeOut() built-in callback function or Web API*/
//     // /*This allows us to run a function in the future, accepts 2 parameters 
//     // 1) A function we want to run in the future
//     // 2) How to wait before running this function (1000ms <=> 1s)
//     // Advantage: doesn't block our code for n seconds, runs in the backgound*/
//     // setTimeout(function(){
//     //   console.log('timeout');
//     //   console.log('timeout2');

//     // },3000)
//     // console.log('Next Line')

//     // /*Asynchronous Code: Won't wait for a line to finish before going to the next line*/
//     // /*Synchronous Code: Control/computer will wait for one line to finish before going to the next line*/
    
//     // /*setInterval() built-in callback function or Web API*/
//     // /*It will keep running the function every n seconds*/
//     // setInterval(function(){
//     //   console.log('i am setInterval built-in method');
//     // },20000);

//     // console.log('Next Line 2')

//     /*Another way to loop through an Array .forEach() method, for(){}, while(){}*/
//     /*arry.forEach((value,index)=>{console.log(value);console.log(index);}); array loop method is the preferred way to loop through an array*/

//   [
//     'make chutiya',
//     'Love Gandu',
//     'Bewafa Love'
//   ].forEach((value,index,arry)=>{     // .forEach() supports return statement(alternative of continue), not continue; and break;
//     // if we need to use break; then it is better to use regular for(){} loop

//     if(value === 'Love Gandu'){
//       return;      // here we skip one iteration of the forEach() loop
//     }
//     console.log(index,value,arry)
//     // console.log(value)
//     // console.log(arry)
//   });

//   /*Practical example using .forEach() array looping method*/
//   // Go to To-do list project and practice

// // shorter way of writing functions ARROW Functions
// // Arrow function mostly works the same as a regular function
// // It's recommended to use Arrow function insdie setTimeout,setInterval,.map(),.forEach(),.filter(),.reduce(),.addEventListener() and many more places.

// const regularFunction = function(){
//   console.log('I am regular function')
//   return 3*8;
// }
// console.log(regularFunction());

// const arrowFunction = ()=>{
//   console.log('I am arrow Function')
//   return 2+3;
// }
// console.log(arrowFunction());

// const oneParam = param => {
//   return param * 4;
// };
// console.log('I have one parameter: '+ oneParam(2))

// const oneLine = (param,param2) => param*param2 ;
// console.log('I have two paramter: '+ oneLine(2,5))

// /*Another places we can use Arrow function */
// const object2 = {
//   method: ()=>{
//     // this is not recommended
//   },
//   method(){
//     // this is recommended
//     //Best shorthand method creation inside object
//   }
// };



/* 
2 more array methods 
1) .filter() // filter works same as .forEach() array method only difference filter returns true/false boolean value and value put inside newly created array, if inner function return true then filter puts that value inside newly created array or else leave.
2) .map()
*/

/* [1, -5, 3] <=> [1, 3] Negative number removed */
console.log([1, -5, 3].filter((value, index)=>{
  // if(value > 0){
  //   return true;
  // }else{
  //   return false;
  // }

  return value > 0 ;  // shorthand 
}));

/* [1,1, 6] make a copy of array with each number double <=> [2,2, 12]
2) .map() just like work as .forEach and .filter but it is use to transform ex: - array into object or object into array so on..
*/
const arry = [1, 8, 6, 3];
// const result = arry.map((value, index)=>{
//       return {
//         num: arry[index] *2,
//       };
// });

const result = arry.map(value => value * 2);  // shorter form 
console.log(arry);
console.log(result);



/*
Closure Advanced Function concept 
* If a function have access to a value, it will always have access to thAT value
* Every function is closing coupled to their lexical environment
* Inner functions have access to all data to their outter function data, but outter function doesn't have access to their inner function
*Closures Naturally happens as we write JavaScript code
*/

  </script>
  
</body>
</html>